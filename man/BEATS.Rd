% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BEATS.R
\name{BEATS}
\alias{BEATS}
\title{Bayesian joint modeling of single-cell expression data and bulk spatial transcriptomic data}
\usage{
BEATS(
  scRNA_data_matr,
  ST_data_matr,
  spot_matr,
  n_celltype,
  n_region,
  warm_cluster_label_init = FALSE,
  num_iterations = 10000,
  num_burnin = floor(num_iterations/2),
  collect_post_sample = FALSE,
  hyperparameters = c(0, 5, 2, 0.1, 1000, 3, 0.1, 5, 0.01, 1, 0, 10, 0.2, 20, 2, -2,
    0.25, 0.25, 0.01, 10),
  hyperparameters_conc = list(rep(2, n_celltype), matrix(3, n_celltype, n_region)),
  print_label = FALSE,
  print_per_iteration = 1000
)
}
\arguments{
\item{scRNA_data_matr}{The scRNA-seq data matrix, where rows represent genes and columns represent cells. Matrix values need to be non-negative and continuous after adjusting for cellsâ€™ library sizes. Please do not take logarithm during data preprocessing.}

\item{ST_data_matr}{The bulk spatial transcriptomic (ST) data matrix, where rows represent genes and columns represent spots. Matrix values need to be normalized first. Noteworthy, the column order of spots has to be consistent with the order of spots in the argument spot_matr. For example, the coordinates of spot 1 are the first row of matrix spot_matr, the coordinates of spot 2 are the second row of matrix spot_matr, and so on.}

\item{spot_matr}{The coordinate matrix of ST data, where the first column represents row indices of spots and the second column represents column indices of spots.}

\item{n_celltype}{An integer, denoting the number of cell types.}

\item{n_region}{An integer, denoting the number of regions.}

\item{warm_cluster_label_init}{The initialization of cluster labels is random or based on k-means. The default is FALSE, corresponding to the random initialization.}

\item{num_iterations}{The number of Gibbs sampler iterations. The default is 10000.}

\item{num_burnin}{The number of iterations in burn-in, after which the posterior samples are used to estimate the unknown parameters. The default is the first half of total iterations.}

\item{collect_post_sample}{Logical, collect the posterior samples or not. If users are only interested in the estimates, set it as FALSE to save the memory. If users would like to use posterior samples to construct credible intervals or for other uses, set it as TRUE. The default is FALSE.}

\item{hyperparameters}{A vector, which indicates 20 hyper-parameters in the priors or proposal distributions. The first two elements are the mean and standard deviation of the normal prior distribution for \eqn{\mu} respectively. The third and fourth elements represent the shape and rate of inverse-gamma prior distribution for cell-type expression variance. The fifth element is the sum of all the concentration parameters of the Dirichlet proposal distribution for vector \eqn{p_s} where s is the region number. The sixth and seventh elements correspond to the shape and rate of inverse-gamma prior distribution for error variance respectively, while the eighth and ninth elements are the shape and rate of inverse-gamma prior distribution for bulk expression data expression variance respectively. The tenth element stands for the standard deviation of the normal proposal distribution for \eqn{\psi}. The eleventh and twelfth elements represent the mean and standard deviation of the normal prior distribution for \eqn{\psi} respectively. The thirteenth and fourteenth elements correspond to the step size and step number of leapfrog iteration for \eqn{\theta} respectively. The fifteenth and sixteenth elements are, respectively, the means of the normal priors for \eqn{\lambda_0} and \eqn{\lambda_1}. The seventeenth and eighteenth elements correspond to the variances of the normal priors for \eqn{\lambda_0} and \eqn{\lambda_1} respectively. The last two elements are the step size and step number of leapfrog iteration for \eqn{\lambda} respectively. The default is 0, 5, 2, 0.1, 1000, 3, 0.1, 5, 0.01, 1, 0, 10, 0.2, 20, 2, -2, 0.25, 0.25, 0.01, 10.}

\item{hyperparameters_conc}{A list, the first element is a vector of n_celltype dimension, describing the parameters of Dirichlet prior for \eqn{\pi}. The default is a vector filled with two. The latter one is a matrix with n_celltype rows and n_region columns, the s-th column vector is the parameters of Dirichlet prior for \eqn{p_s}. The default is a matrix with each element being three.}

\item{print_label}{Logical, whether or not to print summarized cell type label and spot region label information after each iteration. The default is FALSE.}

\item{print_per_iteration}{Integer, how many iterations to print the iteration information when print_label is FALSE. The default is 1000.}
}
\value{
BEATS returns an R list including the following information.
\item{cell_labels}{A vector, indicating the estimated cell types for each cell.}
\item{region_labels}{A vector, indicating the estimated region types for each spot.}
\item{cell_type_mean_expr}{A matrix of cell type expression profiles, in which rows are genes and columns correspond to cell types.}
\item{prop}{A matrix of cell type proportions in each region, in which rows are cell types and columns are regions. Specifically, prop[k, s] is the proportion of cell type k in region s.}
\item{region_mean_expr}{A matrix of region expression profiles, in which rows are genes and columns correspond to region types.}
\item{lam0}{A vector, the estimated \eqn{\lambda_0} for each gene.}
\item{lam1}{A vector, the estimated \eqn{\lambda_1} for each gene.}
\item{region_interaction}{A symmetric matrix measures the interaction effects between different types of regions.}
\item{cell_label_post}{Collected posterior samples of cell_labels when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{region_label_post}{Collected posterior samples of region_labels when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{region_interaction_post}{Collected posterior samples of region_interaction when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{prop_post}{Collected posterior samples of prop when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{cell_type_mean_expr_post}{Collected sampls of cell_type_mean_expr when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{lam0_post}{Collected posterior samples of lam0 when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{lam1_post}{Collected posterior samples of lam1 when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{sgm_sq_y_post}{Collected posterior samples of cell-type expression variance when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{sgm_sq_h_post}{Collected posterior samples of error variance when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{sgm_sq_z_post}{Collected posterior samples of bulk expression data expression variance when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{theta_post}{Collected posterior samples of \eqn{\theta} when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
\item{region_mean_expr_post}{Collected posterior samples of region_mean_expr when collect_post_sample is TRUE. If collect_post_sample is FALSE, this output does not exist.}
}
\description{
The function BEATS implements a Bayesian method for integrating scRNA-seq data and bulk ST data. BEATS cluster cells, partition spatial spots into different regions, and obtain cellular enrichments of spots simultaneously. It employs a hybrid Markov chain Monte Carlo algorithm to perform posterior inference.
}
\examples{
#Data generation
set.seed(20200202)
#cell number
n <- 100
#gene number
G <- 50
#number cell types
K <- 2
#number of region states
S <- 3
#length
L <- 10
#width
W <- 10
#spot_matr
ind_mat <- NULL
for (j in 1:10) {
  for(i in 1:10){
    ind_mat <- rbind(ind_mat, c(i, j))
  }
}
spot_matr <- as.matrix(ind_mat)
#region indicators
R <- matrix(1, 10, 10)
R[1:5,1:5] <- 2
R[1:5,6:10] <- 3
R <- c(R)
#spot number
m <- nrow(spot_matr)
#cell cluster proportion
pi_K <- c(0.6, 0.4)
#cell type vector
C <- NULL
for (k in 1:K) {
  C <- c(C, rep(k, n*pi_K[k])) 
}
#cell-type-specific mean
NDE_mu <- rgamma(G,shape = 4,scale = 0.5)
mu_1 <- NDE_mu
mu_2 <- NDE_mu
mu_2[1:(5*G/10)] <- rnorm(5*G/10, mean=rep(c(4,5), each = 2.5*G/10), sd=0.2)
mu <- cbind(mu_1, mu_2)
#cell type proportions in each region
p <- t(rbind(c(0.7, 0.3),
             c(0.4, 0.6),
             c(0.2, 0.8)))
#region effects
h <- matrix(NA, G, S)
for(s in 1:S){
  h[,s] <- rnorm(G, rowSums(sweep(mu, 2, p[,s], "*")), 0.05)
}

#observed expression data 
#scRNA-seq
theta <- matrix(NA, G, n)
for(i in 1:n){
  theta[ ,i] <- rnorm(G, mean = mu[,C[i]], sd = 0.2)
}
lambda0 <- rnorm(G, 1, 0.1) 
lambda1 <- rnorm(G, -1, 0.1) 
X <- exp(theta)
tmp <- pnorm(lambda0 + lambda1 * theta)
r <- matrix(runif(G*n), G, n)
X[r <= tmp] <- 0
scRNA_data_matr <- X

#ST data
Z <- matrix(NA, G, m)    
for(i in 1:m){
  Z[ ,i] <- rnorm(G, mean = h[ ,R[i]], sd = 0.2)
}
ST_data_matr <- Z

#run BayesEATS
library(BayesEATS)
t1 <- Sys.time()
Result <- BEATS(scRNA_data_matr, ST_data_matr, spot_matr, n_celltype = 2,
                n_region = 3, num_iterations = 5000, print_per_iteration = 500)
t2 <- Sys.time()

#time cost
print(t2 - t1)

#Compared with true cell type labels
table(Result$cell_labels, C)

#Compared with true region labels
table(Result$region_labels, R)

#Estimate for the cellular composition matrix
cell_comp <- Result$prop
rownames(cell_comp) <- c("cell type 1", "cell type 2")
colnames(cell_comp) <- c("region 1", "region 2", "region 3")
cell_comp

}
\references{

}
